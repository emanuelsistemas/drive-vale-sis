{"ast":null,"code":"import { supabase } from './supabase';\n\n/**\n * Serviço para gerenciar estatísticas e logs de acesso aos arquivos\n */\n\n// Tipos para tabela de logs de acesso\n\n// Tipos para estatísticas de arquivo\n\n// CRUD para logs de acesso\nexport const accessLogCrud = {\n  // Registrar um novo acesso\n  async create(data) {\n    try {\n      const {\n        data: result,\n        error\n      } = await supabase.from('file_access_logs').insert([data]).select();\n      if (error) {\n        console.error('Erro ao registrar acesso:', error);\n        throw error;\n      }\n\n      // Atualizar estatísticas do arquivo\n      await updateFileStats(data.file_id, data.action_type);\n      return result === null || result === void 0 ? void 0 : result[0];\n    } catch (error) {\n      console.error('Erro ao registrar acesso:', error);\n      throw error;\n    }\n  },\n  // Obter logs de acesso de um arquivo\n  async getByFileId(fileId) {\n    try {\n      const {\n        data,\n        error\n      } = await supabase.from('file_access_logs').select(`\n          *,\n          user:user_id(dv_nome, dv_email)\n        `).eq('file_id', fileId).order('created_at', {\n        ascending: false\n      });\n      if (error) {\n        console.error(`Erro ao buscar logs de acesso do arquivo ${fileId}:`, error);\n        throw error;\n      }\n      return data;\n    } catch (error) {\n      console.error(`Erro ao buscar logs de acesso do arquivo ${fileId}:`, error);\n      throw error;\n    }\n  },\n  // Obter logs de acesso de um usuário\n  async getByUserId(userId) {\n    try {\n      const {\n        data,\n        error\n      } = await supabase.from('file_access_logs').select(`\n          *,\n          file:file_id(name, path)\n        `).eq('user_id', userId).order('created_at', {\n        ascending: false\n      });\n      if (error) {\n        console.error(`Erro ao buscar logs de acesso do usuário ${userId}:`, error);\n        throw error;\n      }\n      return data;\n    } catch (error) {\n      console.error(`Erro ao buscar logs de acesso do usuário ${userId}:`, error);\n      throw error;\n    }\n  },\n  // Obter logs de acesso de uma empresa\n  async getByEmpresaId(empresaId) {\n    try {\n      const {\n        data,\n        error\n      } = await supabase.from('file_access_logs').select(`\n          *,\n          file:file_id(name, path),\n          user:user_id(dv_nome, dv_email)\n        `).eq('empresa_id', empresaId).order('created_at', {\n        ascending: false\n      });\n      if (error) {\n        console.error(`Erro ao buscar logs de acesso da empresa ${empresaId}:`, error);\n        throw error;\n      }\n      return data;\n    } catch (error) {\n      console.error(`Erro ao buscar logs de acesso da empresa ${empresaId}:`, error);\n      throw error;\n    }\n  }\n};\n\n// Funções para estatísticas de arquivo\nexport const fileStatsCrud = {\n  // Obter estatísticas de um arquivo\n  async getByFileId(fileId) {\n    try {\n      const {\n        data,\n        error\n      } = await supabase.from('file_stats').select('*').eq('file_id', fileId).single();\n      if (error) {\n        if (error.code === 'PGRST116') {\n          // Nenhum resultado encontrado\n          return {\n            file_id: fileId,\n            views: 0,\n            downloads: 0,\n            shares: 0\n          };\n        }\n        console.error(`Erro ao buscar estatísticas do arquivo ${fileId}:`, error);\n        throw error;\n      }\n      return data;\n    } catch (error) {\n      console.error(`Erro ao buscar estatísticas do arquivo ${fileId}:`, error);\n      throw error;\n    }\n  },\n  // Obter arquivos mais acessados\n  async getMostAccessed(limit = 10, userId, empresaId) {\n    try {\n      let query = supabase.from('file_stats').select(`\n          *,\n          file:file_id(*)\n        `).order('views', {\n        ascending: false\n      }).limit(limit);\n      if (userId || empresaId) {\n        query = query.or(`file.user_id.eq.${userId},file.empresa_id.eq.${empresaId}`);\n      }\n      const {\n        data,\n        error\n      } = await query;\n      if (error) {\n        console.error('Erro ao buscar arquivos mais acessados:', error);\n        throw error;\n      }\n      return data;\n    } catch (error) {\n      console.error('Erro ao buscar arquivos mais acessados:', error);\n      throw error;\n    }\n  },\n  // Obter arquivos mais baixados\n  async getMostDownloaded(limit = 10, userId, empresaId) {\n    try {\n      let query = supabase.from('file_stats').select(`\n          *,\n          file:file_id(*)\n        `).order('downloads', {\n        ascending: false\n      }).limit(limit);\n      if (userId || empresaId) {\n        query = query.or(`file.user_id.eq.${userId},file.empresa_id.eq.${empresaId}`);\n      }\n      const {\n        data,\n        error\n      } = await query;\n      if (error) {\n        console.error('Erro ao buscar arquivos mais baixados:', error);\n        throw error;\n      }\n      return data;\n    } catch (error) {\n      console.error('Erro ao buscar arquivos mais baixados:', error);\n      throw error;\n    }\n  }\n};\n\n// Função auxiliar para atualizar estatísticas de arquivo\nasync function updateFileStats(fileId, actionType) {\n  try {\n    // Verificar se já existem estatísticas para o arquivo\n    const {\n      data,\n      error\n    } = await supabase.from('file_stats').select('*').eq('file_id', fileId);\n    if (error) {\n      console.error(`Erro ao verificar estatísticas do arquivo ${fileId}:`, error);\n      throw error;\n    }\n\n    // Se não existem estatísticas, criar um novo registro\n    if (!data || data.length === 0) {\n      const newStats = {\n        file_id: fileId,\n        views: 0,\n        downloads: 0,\n        shares: 0,\n        last_accessed: new Date().toISOString()\n      };\n\n      // Incrementar o contador apropriado\n      if (actionType === 'view') newStats.views = 1;else if (actionType === 'download') newStats.downloads = 1;else if (actionType === 'share') newStats.shares = 1;\n      const {\n        error: insertError\n      } = await supabase.from('file_stats').insert([newStats]);\n      if (insertError) {\n        console.error(`Erro ao criar estatísticas do arquivo ${fileId}:`, insertError);\n        throw insertError;\n      }\n      return;\n    }\n\n    // Se já existem estatísticas, atualizar o registro\n    const updateData = {\n      last_accessed: new Date().toISOString()\n    };\n\n    // Incrementar o contador apropriado\n    if (actionType === 'view') {\n      updateData.views = data[0].views + 1;\n    } else if (actionType === 'download') {\n      updateData.downloads = data[0].downloads + 1;\n    } else if (actionType === 'share') {\n      updateData.shares = data[0].shares + 1;\n    }\n    const {\n      error: updateError\n    } = await supabase.from('file_stats').update(updateData).eq('file_id', fileId);\n    if (updateError) {\n      console.error(`Erro ao atualizar estatísticas do arquivo ${fileId}:`, updateError);\n      throw updateError;\n    }\n  } catch (error) {\n    console.error(`Erro ao atualizar estatísticas do arquivo ${fileId}:`, error);\n    throw error;\n  }\n}\n\n// Função para registrar acesso a um arquivo\nexport const logFileAccess = async (fileId, userId, actionType, empresaId, ipAddress, userAgent) => {\n  try {\n    return await accessLogCrud.create({\n      file_id: fileId,\n      user_id: userId,\n      action_type: actionType,\n      empresa_id: empresaId,\n      ip_address: ipAddress,\n      user_agent: userAgent\n    });\n  } catch (error) {\n    console.error(`Erro ao registrar acesso ao arquivo ${fileId}:`, error);\n    // Não lançar erro para não interromper o fluxo principal\n  }\n};\n\n// Função para criar tabelas de estatísticas no Supabase\nexport const createStatsTables = async () => {\n  try {\n    // Verificar se a tabela de logs de acesso existe\n    const {\n      error: checkLogsError\n    } = await supabase.rpc('exec', {\n      query: `SELECT to_regclass('public.file_access_logs');`\n    });\n    if (checkLogsError) {\n      console.log('Criando tabela de logs de acesso...');\n\n      // Criar a tabela file_access_logs\n      const createLogsQuery = `\n        CREATE TABLE IF NOT EXISTS file_access_logs (\n          id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,\n          file_id BIGINT REFERENCES files(id) ON DELETE CASCADE,\n          user_id TEXT NOT NULL,\n          empresa_id BIGINT REFERENCES dv_cad_empresas_drive(id),\n          action_type TEXT CHECK (action_type IN ('view', 'download', 'edit', 'share', 'delete')) NOT NULL,\n          created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n          ip_address TEXT,\n          user_agent TEXT\n        );\n        \n        CREATE INDEX IF NOT EXISTS idx_file_access_logs_file_id ON file_access_logs(file_id);\n        CREATE INDEX IF NOT EXISTS idx_file_access_logs_user_id ON file_access_logs(user_id);\n        CREATE INDEX IF NOT EXISTS idx_file_access_logs_empresa_id ON file_access_logs(empresa_id);\n        CREATE INDEX IF NOT EXISTS idx_file_access_logs_action_type ON file_access_logs(action_type);\n        CREATE INDEX IF NOT EXISTS idx_file_access_logs_created_at ON file_access_logs(created_at);\n      `;\n      const {\n        error: createLogsError\n      } = await supabase.rpc('exec', {\n        query: createLogsQuery\n      });\n      if (createLogsError) {\n        console.error('Erro ao criar tabela de logs de acesso:', createLogsError);\n        throw createLogsError;\n      }\n    }\n\n    // Verificar se a tabela de estatísticas existe\n    const {\n      error: checkStatsError\n    } = await supabase.rpc('exec', {\n      query: `SELECT to_regclass('public.file_stats');`\n    });\n    if (checkStatsError) {\n      console.log('Criando tabela de estatísticas de arquivo...');\n\n      // Criar a tabela file_stats\n      const createStatsQuery = `\n        CREATE TABLE IF NOT EXISTS file_stats (\n          file_id BIGINT PRIMARY KEY REFERENCES files(id) ON DELETE CASCADE,\n          views BIGINT DEFAULT 0,\n          downloads BIGINT DEFAULT 0,\n          shares BIGINT DEFAULT 0,\n          last_accessed TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n        );\n        \n        CREATE INDEX IF NOT EXISTS idx_file_stats_views ON file_stats(views);\n        CREATE INDEX IF NOT EXISTS idx_file_stats_downloads ON file_stats(downloads);\n        CREATE INDEX IF NOT EXISTS idx_file_stats_last_accessed ON file_stats(last_accessed);\n      `;\n      const {\n        error: createStatsError\n      } = await supabase.rpc('exec', {\n        query: createStatsQuery\n      });\n      if (createStatsError) {\n        console.error('Erro ao criar tabela de estatísticas de arquivo:', createStatsError);\n        throw createStatsError;\n      }\n    }\n    return {\n      success: true\n    };\n  } catch (error) {\n    console.error('Erro ao criar tabelas de estatísticas:', error);\n    return {\n      success: false,\n      error\n    };\n  }\n};","map":{"version":3,"names":["supabase","accessLogCrud","create","data","result","error","from","insert","select","console","updateFileStats","file_id","action_type","getByFileId","fileId","eq","order","ascending","getByUserId","userId","getByEmpresaId","empresaId","fileStatsCrud","single","code","views","downloads","shares","getMostAccessed","limit","query","or","getMostDownloaded","actionType","length","newStats","last_accessed","Date","toISOString","insertError","updateData","updateError","update","logFileAccess","ipAddress","userAgent","user_id","empresa_id","ip_address","user_agent","createStatsTables","checkLogsError","rpc","log","createLogsQuery","createLogsError","checkStatsError","createStatsQuery","createStatsError","success"],"sources":["/root/m-software/drive-react/src/services/statsService.ts"],"sourcesContent":["import { supabase } from './supabase';\n\n/**\n * Serviço para gerenciar estatísticas e logs de acesso aos arquivos\n */\n\n// Tipos para tabela de logs de acesso\nexport interface FileAccessLog {\n  id?: number;\n  file_id: number;\n  user_id: string;\n  empresa_id?: number;\n  action_type: 'view' | 'download' | 'edit' | 'share' | 'delete';\n  created_at?: string;\n  ip_address?: string;\n  user_agent?: string;\n}\n\n// Tipos para estatísticas de arquivo\nexport interface FileStats {\n  file_id: number;\n  views: number;\n  downloads: number;\n  shares: number;\n  last_accessed?: string;\n}\n\n// CRUD para logs de acesso\nexport const accessLogCrud = {\n  // Registrar um novo acesso\n  async create(data: FileAccessLog) {\n    try {\n      const { data: result, error } = await supabase\n        .from('file_access_logs')\n        .insert([data])\n        .select();\n      \n      if (error) {\n        console.error('Erro ao registrar acesso:', error);\n        throw error;\n      }\n      \n      // Atualizar estatísticas do arquivo\n      await updateFileStats(data.file_id, data.action_type);\n      \n      return result?.[0];\n    } catch (error) {\n      console.error('Erro ao registrar acesso:', error);\n      throw error;\n    }\n  },\n  \n  // Obter logs de acesso de um arquivo\n  async getByFileId(fileId: number) {\n    try {\n      const { data, error } = await supabase\n        .from('file_access_logs')\n        .select(`\n          *,\n          user:user_id(dv_nome, dv_email)\n        `)\n        .eq('file_id', fileId)\n        .order('created_at', { ascending: false });\n      \n      if (error) {\n        console.error(`Erro ao buscar logs de acesso do arquivo ${fileId}:`, error);\n        throw error;\n      }\n      \n      return data;\n    } catch (error) {\n      console.error(`Erro ao buscar logs de acesso do arquivo ${fileId}:`, error);\n      throw error;\n    }\n  },\n  \n  // Obter logs de acesso de um usuário\n  async getByUserId(userId: string) {\n    try {\n      const { data, error } = await supabase\n        .from('file_access_logs')\n        .select(`\n          *,\n          file:file_id(name, path)\n        `)\n        .eq('user_id', userId)\n        .order('created_at', { ascending: false });\n      \n      if (error) {\n        console.error(`Erro ao buscar logs de acesso do usuário ${userId}:`, error);\n        throw error;\n      }\n      \n      return data;\n    } catch (error) {\n      console.error(`Erro ao buscar logs de acesso do usuário ${userId}:`, error);\n      throw error;\n    }\n  },\n  \n  // Obter logs de acesso de uma empresa\n  async getByEmpresaId(empresaId: number) {\n    try {\n      const { data, error } = await supabase\n        .from('file_access_logs')\n        .select(`\n          *,\n          file:file_id(name, path),\n          user:user_id(dv_nome, dv_email)\n        `)\n        .eq('empresa_id', empresaId)\n        .order('created_at', { ascending: false });\n      \n      if (error) {\n        console.error(`Erro ao buscar logs de acesso da empresa ${empresaId}:`, error);\n        throw error;\n      }\n      \n      return data;\n    } catch (error) {\n      console.error(`Erro ao buscar logs de acesso da empresa ${empresaId}:`, error);\n      throw error;\n    }\n  }\n};\n\n// Funções para estatísticas de arquivo\nexport const fileStatsCrud = {\n  // Obter estatísticas de um arquivo\n  async getByFileId(fileId: number) {\n    try {\n      const { data, error } = await supabase\n        .from('file_stats')\n        .select('*')\n        .eq('file_id', fileId)\n        .single();\n      \n      if (error) {\n        if (error.code === 'PGRST116') { // Nenhum resultado encontrado\n          return {\n            file_id: fileId,\n            views: 0,\n            downloads: 0,\n            shares: 0\n          };\n        }\n        \n        console.error(`Erro ao buscar estatísticas do arquivo ${fileId}:`, error);\n        throw error;\n      }\n      \n      return data;\n    } catch (error) {\n      console.error(`Erro ao buscar estatísticas do arquivo ${fileId}:`, error);\n      throw error;\n    }\n  },\n  \n  // Obter arquivos mais acessados\n  async getMostAccessed(limit = 10, userId?: string, empresaId?: number) {\n    try {\n      let query = supabase\n        .from('file_stats')\n        .select(`\n          *,\n          file:file_id(*)\n        `)\n        .order('views', { ascending: false })\n        .limit(limit);\n      \n      if (userId || empresaId) {\n        query = query.or(`file.user_id.eq.${userId},file.empresa_id.eq.${empresaId}`);\n      }\n      \n      const { data, error } = await query;\n      \n      if (error) {\n        console.error('Erro ao buscar arquivos mais acessados:', error);\n        throw error;\n      }\n      \n      return data;\n    } catch (error) {\n      console.error('Erro ao buscar arquivos mais acessados:', error);\n      throw error;\n    }\n  },\n  \n  // Obter arquivos mais baixados\n  async getMostDownloaded(limit = 10, userId?: string, empresaId?: number) {\n    try {\n      let query = supabase\n        .from('file_stats')\n        .select(`\n          *,\n          file:file_id(*)\n        `)\n        .order('downloads', { ascending: false })\n        .limit(limit);\n      \n      if (userId || empresaId) {\n        query = query.or(`file.user_id.eq.${userId},file.empresa_id.eq.${empresaId}`);\n      }\n      \n      const { data, error } = await query;\n      \n      if (error) {\n        console.error('Erro ao buscar arquivos mais baixados:', error);\n        throw error;\n      }\n      \n      return data;\n    } catch (error) {\n      console.error('Erro ao buscar arquivos mais baixados:', error);\n      throw error;\n    }\n  }\n};\n\n// Função auxiliar para atualizar estatísticas de arquivo\nasync function updateFileStats(fileId: number, actionType: string) {\n  try {\n    // Verificar se já existem estatísticas para o arquivo\n    const { data, error } = await supabase\n      .from('file_stats')\n      .select('*')\n      .eq('file_id', fileId);\n    \n    if (error) {\n      console.error(`Erro ao verificar estatísticas do arquivo ${fileId}:`, error);\n      throw error;\n    }\n    \n    // Se não existem estatísticas, criar um novo registro\n    if (!data || data.length === 0) {\n      const newStats: any = {\n        file_id: fileId,\n        views: 0,\n        downloads: 0,\n        shares: 0,\n        last_accessed: new Date().toISOString()\n      };\n      \n      // Incrementar o contador apropriado\n      if (actionType === 'view') newStats.views = 1;\n      else if (actionType === 'download') newStats.downloads = 1;\n      else if (actionType === 'share') newStats.shares = 1;\n      \n      const { error: insertError } = await supabase\n        .from('file_stats')\n        .insert([newStats]);\n      \n      if (insertError) {\n        console.error(`Erro ao criar estatísticas do arquivo ${fileId}:`, insertError);\n        throw insertError;\n      }\n      \n      return;\n    }\n    \n    // Se já existem estatísticas, atualizar o registro\n    const updateData: any = {\n      last_accessed: new Date().toISOString()\n    };\n    \n    // Incrementar o contador apropriado\n    if (actionType === 'view') {\n      updateData.views = data[0].views + 1;\n    } else if (actionType === 'download') {\n      updateData.downloads = data[0].downloads + 1;\n    } else if (actionType === 'share') {\n      updateData.shares = data[0].shares + 1;\n    }\n    \n    const { error: updateError } = await supabase\n      .from('file_stats')\n      .update(updateData)\n      .eq('file_id', fileId);\n    \n    if (updateError) {\n      console.error(`Erro ao atualizar estatísticas do arquivo ${fileId}:`, updateError);\n      throw updateError;\n    }\n  } catch (error) {\n    console.error(`Erro ao atualizar estatísticas do arquivo ${fileId}:`, error);\n    throw error;\n  }\n}\n\n// Função para registrar acesso a um arquivo\nexport const logFileAccess = async (\n  fileId: number,\n  userId: string,\n  actionType: 'view' | 'download' | 'edit' | 'share' | 'delete',\n  empresaId?: number,\n  ipAddress?: string,\n  userAgent?: string\n) => {\n  try {\n    return await accessLogCrud.create({\n      file_id: fileId,\n      user_id: userId,\n      action_type: actionType,\n      empresa_id: empresaId,\n      ip_address: ipAddress,\n      user_agent: userAgent\n    });\n  } catch (error) {\n    console.error(`Erro ao registrar acesso ao arquivo ${fileId}:`, error);\n    // Não lançar erro para não interromper o fluxo principal\n  }\n};\n\n// Função para criar tabelas de estatísticas no Supabase\nexport const createStatsTables = async () => {\n  try {\n    // Verificar se a tabela de logs de acesso existe\n    const { error: checkLogsError } = await supabase.rpc('exec', { \n      query: `SELECT to_regclass('public.file_access_logs');` \n    });\n    \n    if (checkLogsError) {\n      console.log('Criando tabela de logs de acesso...');\n      \n      // Criar a tabela file_access_logs\n      const createLogsQuery = `\n        CREATE TABLE IF NOT EXISTS file_access_logs (\n          id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,\n          file_id BIGINT REFERENCES files(id) ON DELETE CASCADE,\n          user_id TEXT NOT NULL,\n          empresa_id BIGINT REFERENCES dv_cad_empresas_drive(id),\n          action_type TEXT CHECK (action_type IN ('view', 'download', 'edit', 'share', 'delete')) NOT NULL,\n          created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n          ip_address TEXT,\n          user_agent TEXT\n        );\n        \n        CREATE INDEX IF NOT EXISTS idx_file_access_logs_file_id ON file_access_logs(file_id);\n        CREATE INDEX IF NOT EXISTS idx_file_access_logs_user_id ON file_access_logs(user_id);\n        CREATE INDEX IF NOT EXISTS idx_file_access_logs_empresa_id ON file_access_logs(empresa_id);\n        CREATE INDEX IF NOT EXISTS idx_file_access_logs_action_type ON file_access_logs(action_type);\n        CREATE INDEX IF NOT EXISTS idx_file_access_logs_created_at ON file_access_logs(created_at);\n      `;\n      \n      const { error: createLogsError } = await supabase.rpc('exec', { \n        query: createLogsQuery \n      });\n      \n      if (createLogsError) {\n        console.error('Erro ao criar tabela de logs de acesso:', createLogsError);\n        throw createLogsError;\n      }\n    }\n    \n    // Verificar se a tabela de estatísticas existe\n    const { error: checkStatsError } = await supabase.rpc('exec', { \n      query: `SELECT to_regclass('public.file_stats');` \n    });\n    \n    if (checkStatsError) {\n      console.log('Criando tabela de estatísticas de arquivo...');\n      \n      // Criar a tabela file_stats\n      const createStatsQuery = `\n        CREATE TABLE IF NOT EXISTS file_stats (\n          file_id BIGINT PRIMARY KEY REFERENCES files(id) ON DELETE CASCADE,\n          views BIGINT DEFAULT 0,\n          downloads BIGINT DEFAULT 0,\n          shares BIGINT DEFAULT 0,\n          last_accessed TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n        );\n        \n        CREATE INDEX IF NOT EXISTS idx_file_stats_views ON file_stats(views);\n        CREATE INDEX IF NOT EXISTS idx_file_stats_downloads ON file_stats(downloads);\n        CREATE INDEX IF NOT EXISTS idx_file_stats_last_accessed ON file_stats(last_accessed);\n      `;\n      \n      const { error: createStatsError } = await supabase.rpc('exec', { \n        query: createStatsQuery \n      });\n      \n      if (createStatsError) {\n        console.error('Erro ao criar tabela de estatísticas de arquivo:', createStatsError);\n        throw createStatsError;\n      }\n    }\n    \n    return { success: true };\n  } catch (error) {\n    console.error('Erro ao criar tabelas de estatísticas:', error);\n    return { success: false, error };\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}