{"ast":null,"code":"import { supabase } from './supabase';\n\n/**\n * Função para corrigir as políticas RLS que estão causando recursão infinita\n */\nexport const fixRlsPolicies = async () => {\n  try {\n    console.log('Iniciando correção das políticas RLS...');\n\n    // SQL com os comandos para corrigir as políticas RLS\n    const sqlCommands = [\n    // Remover políticas existentes\n    \"DROP POLICY IF EXISTS \\\"Usuários podem ver seus próprios dados\\\" ON \\\"cad_emp_user\\\"\", \"DROP POLICY IF EXISTS \\\"Administradores podem ver todos os usuários\\\" ON \\\"cad_emp_user\\\"\", \"DROP POLICY IF EXISTS \\\"Administradores podem inserir usuários\\\" ON \\\"cad_emp_user\\\"\", \"DROP POLICY IF EXISTS \\\"Administradores podem atualizar usuários\\\" ON \\\"cad_emp_user\\\"\", \"DROP POLICY IF EXISTS \\\"Administradores podem excluir usuários\\\" ON \\\"cad_emp_user\\\"\",\n    // Desabilitar temporariamente RLS\n    \"ALTER TABLE \\\"cad_emp_user\\\" DISABLE ROW LEVEL SECURITY\",\n    // Criar função segura para verificar se é admin\n    `CREATE OR REPLACE FUNCTION is_admin_safe()\n      RETURNS BOOLEAN AS $$\n      DECLARE\n        user_id TEXT;\n        admin_profile_id UUID;\n        is_admin BOOLEAN;\n      BEGIN\n        -- Obter o ID do usuário atual\n        user_id := auth.uid();\n        \n        IF user_id IS NULL THEN\n          RETURN FALSE;\n        END IF;\n        \n        -- Obter o ID do perfil 'admin'\n        SELECT id INTO admin_profile_id FROM perfil_acesso WHERE tipo = 'admin';\n        \n        -- Verificar diretamente se o usuário tem perfil de admin\n        EXECUTE 'SELECT EXISTS (\n          SELECT 1 \n          FROM cad_emp_user \n          WHERE auth_id = $1 \n          AND perfil_id = $2\n        )' INTO is_admin USING user_id, admin_profile_id;\n        \n        RETURN COALESCE(is_admin, FALSE);\n      END;\n      $$ LANGUAGE plpgsql SECURITY DEFINER`,\n    // Reabilitar RLS\n    \"ALTER TABLE \\\"cad_emp_user\\\" ENABLE ROW LEVEL SECURITY\",\n    // Criar novas políticas\n    `CREATE POLICY \\\"Usuários podem ver seus próprios dados\\\" \n      ON \\\"cad_emp_user\\\" \n      FOR SELECT \n      USING (auth.uid() = auth_id)`, `CREATE POLICY \\\"Administradores podem ver todos os usuários\\\" \n      ON \\\"cad_emp_user\\\" \n      FOR SELECT \n      USING (is_admin_safe())`, `CREATE POLICY \\\"Administradores podem inserir usuários\\\" \n      ON \\\"cad_emp_user\\\" \n      FOR INSERT \n      WITH CHECK (is_admin_safe() OR auth.uid() IS NULL)`, `CREATE POLICY \\\"Administradores podem atualizar usuários\\\" \n      ON \\\"cad_emp_user\\\" \n      FOR UPDATE \n      USING (is_admin_safe())`, `CREATE POLICY \\\"Administradores podem excluir usuários\\\" \n      ON \\\"cad_emp_user\\\" \n      FOR DELETE \n      USING (is_admin_safe())`,\n    // Atualizar a função is_admin\n    `CREATE OR REPLACE FUNCTION is_admin(user_id TEXT)\n      RETURNS BOOLEAN AS $$\n      DECLARE\n        admin_profile_id UUID;\n        is_admin BOOLEAN;\n      BEGIN\n        -- Obter o ID do perfil 'admin'\n        SELECT id INTO admin_profile_id FROM perfil_acesso WHERE tipo = 'admin';\n        \n        -- Verificar se o usuário tem perfil de admin\n        EXECUTE 'SELECT EXISTS (\n          SELECT 1 \n          FROM cad_emp_user \n          WHERE auth_id = $1 \n          AND perfil_id = $2\n        )' INTO is_admin USING user_id, admin_profile_id;\n        \n        RETURN COALESCE(is_admin, FALSE);\n      END;\n      $$ LANGUAGE plpgsql SECURITY DEFINER`];\n\n    // Executar cada comando SQL\n    for (const command of sqlCommands) {\n      try {\n        const {\n          error\n        } = await supabase.rpc('exec', {\n          query: command + ';'\n        });\n        if (error) {\n          console.error('Erro ao executar comando SQL:', error);\n          console.error('Comando:', command);\n        }\n      } catch (err) {\n        console.error('Exceção ao executar comando SQL:', err);\n        console.error('Comando:', command);\n      }\n    }\n    console.log('Correção das políticas RLS concluída!');\n    return {\n      success: true\n    };\n  } catch (error) {\n    console.error('Erro ao corrigir políticas RLS:', error);\n    return {\n      success: false,\n      error\n    };\n  }\n};\nexport default fixRlsPolicies;","map":{"version":3,"names":["supabase","fixRlsPolicies","console","log","sqlCommands","command","error","rpc","query","err","success"],"sources":["/root/m-software/drive-react/src/services/fixRlsPolicies.ts"],"sourcesContent":["import { supabase } from './supabase';\n\n/**\n * Função para corrigir as políticas RLS que estão causando recursão infinita\n */\nexport const fixRlsPolicies = async () => {\n  try {\n    console.log('Iniciando correção das políticas RLS...');\n    \n    // SQL com os comandos para corrigir as políticas RLS\n    const sqlCommands = [\n      // Remover políticas existentes\n      \"DROP POLICY IF EXISTS \\\"Usuários podem ver seus próprios dados\\\" ON \\\"cad_emp_user\\\"\",\n      \"DROP POLICY IF EXISTS \\\"Administradores podem ver todos os usuários\\\" ON \\\"cad_emp_user\\\"\",\n      \"DROP POLICY IF EXISTS \\\"Administradores podem inserir usuários\\\" ON \\\"cad_emp_user\\\"\",\n      \"DROP POLICY IF EXISTS \\\"Administradores podem atualizar usuários\\\" ON \\\"cad_emp_user\\\"\",\n      \"DROP POLICY IF EXISTS \\\"Administradores podem excluir usuários\\\" ON \\\"cad_emp_user\\\"\",\n      \n      // Desabilitar temporariamente RLS\n      \"ALTER TABLE \\\"cad_emp_user\\\" DISABLE ROW LEVEL SECURITY\",\n      \n      // Criar função segura para verificar se é admin\n      `CREATE OR REPLACE FUNCTION is_admin_safe()\n      RETURNS BOOLEAN AS $$\n      DECLARE\n        user_id TEXT;\n        admin_profile_id UUID;\n        is_admin BOOLEAN;\n      BEGIN\n        -- Obter o ID do usuário atual\n        user_id := auth.uid();\n        \n        IF user_id IS NULL THEN\n          RETURN FALSE;\n        END IF;\n        \n        -- Obter o ID do perfil 'admin'\n        SELECT id INTO admin_profile_id FROM perfil_acesso WHERE tipo = 'admin';\n        \n        -- Verificar diretamente se o usuário tem perfil de admin\n        EXECUTE 'SELECT EXISTS (\n          SELECT 1 \n          FROM cad_emp_user \n          WHERE auth_id = $1 \n          AND perfil_id = $2\n        )' INTO is_admin USING user_id, admin_profile_id;\n        \n        RETURN COALESCE(is_admin, FALSE);\n      END;\n      $$ LANGUAGE plpgsql SECURITY DEFINER`,\n      \n      // Reabilitar RLS\n      \"ALTER TABLE \\\"cad_emp_user\\\" ENABLE ROW LEVEL SECURITY\",\n      \n      // Criar novas políticas\n      `CREATE POLICY \\\"Usuários podem ver seus próprios dados\\\" \n      ON \\\"cad_emp_user\\\" \n      FOR SELECT \n      USING (auth.uid() = auth_id)`,\n      \n      `CREATE POLICY \\\"Administradores podem ver todos os usuários\\\" \n      ON \\\"cad_emp_user\\\" \n      FOR SELECT \n      USING (is_admin_safe())`,\n      \n      `CREATE POLICY \\\"Administradores podem inserir usuários\\\" \n      ON \\\"cad_emp_user\\\" \n      FOR INSERT \n      WITH CHECK (is_admin_safe() OR auth.uid() IS NULL)`,\n      \n      `CREATE POLICY \\\"Administradores podem atualizar usuários\\\" \n      ON \\\"cad_emp_user\\\" \n      FOR UPDATE \n      USING (is_admin_safe())`,\n      \n      `CREATE POLICY \\\"Administradores podem excluir usuários\\\" \n      ON \\\"cad_emp_user\\\" \n      FOR DELETE \n      USING (is_admin_safe())`,\n      \n      // Atualizar a função is_admin\n      `CREATE OR REPLACE FUNCTION is_admin(user_id TEXT)\n      RETURNS BOOLEAN AS $$\n      DECLARE\n        admin_profile_id UUID;\n        is_admin BOOLEAN;\n      BEGIN\n        -- Obter o ID do perfil 'admin'\n        SELECT id INTO admin_profile_id FROM perfil_acesso WHERE tipo = 'admin';\n        \n        -- Verificar se o usuário tem perfil de admin\n        EXECUTE 'SELECT EXISTS (\n          SELECT 1 \n          FROM cad_emp_user \n          WHERE auth_id = $1 \n          AND perfil_id = $2\n        )' INTO is_admin USING user_id, admin_profile_id;\n        \n        RETURN COALESCE(is_admin, FALSE);\n      END;\n      $$ LANGUAGE plpgsql SECURITY DEFINER`\n    ];\n    \n    // Executar cada comando SQL\n    for (const command of sqlCommands) {\n      try {\n        const { error } = await supabase.rpc('exec', { \n          query: command + ';' \n        });\n        \n        if (error) {\n          console.error('Erro ao executar comando SQL:', error);\n          console.error('Comando:', command);\n        }\n      } catch (err) {\n        console.error('Exceção ao executar comando SQL:', err);\n        console.error('Comando:', command);\n      }\n    }\n    \n    console.log('Correção das políticas RLS concluída!');\n    return { success: true };\n  } catch (error) {\n    console.error('Erro ao corrigir políticas RLS:', error);\n    return { success: false, error };\n  }\n};\n\nexport default fixRlsPolicies;\n"],"mappings":"AAAA,SAASA,QAAQ,QAAQ,YAAY;;AAErC;AACA;AACA;AACA,OAAO,MAAMC,cAAc,GAAG,MAAAA,CAAA,KAAY;EACxC,IAAI;IACFC,OAAO,CAACC,GAAG,CAAC,yCAAyC,CAAC;;IAEtD;IACA,MAAMC,WAAW,GAAG;IAClB;IACA,sFAAsF,EACtF,2FAA2F,EAC3F,sFAAsF,EACtF,wFAAwF,EACxF,sFAAsF;IAEtF;IACA,yDAAyD;IAEzD;IACA;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;IAErC;IACA,wDAAwD;IAExD;IACA;AACN;AACA;AACA,mCAAmC,EAE7B;AACN;AACA;AACA,8BAA8B,EAExB;AACN;AACA;AACA,yDAAyD,EAEnD;AACN;AACA;AACA,8BAA8B,EAExB;AACN;AACA;AACA,8BAA8B;IAExB;IACA;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,CACtC;;IAED;IACA,KAAK,MAAMC,OAAO,IAAID,WAAW,EAAE;MACjC,IAAI;QACF,MAAM;UAAEE;QAAM,CAAC,GAAG,MAAMN,QAAQ,CAACO,GAAG,CAAC,MAAM,EAAE;UAC3CC,KAAK,EAAEH,OAAO,GAAG;QACnB,CAAC,CAAC;QAEF,IAAIC,KAAK,EAAE;UACTJ,OAAO,CAACI,KAAK,CAAC,+BAA+B,EAAEA,KAAK,CAAC;UACrDJ,OAAO,CAACI,KAAK,CAAC,UAAU,EAAED,OAAO,CAAC;QACpC;MACF,CAAC,CAAC,OAAOI,GAAG,EAAE;QACZP,OAAO,CAACI,KAAK,CAAC,kCAAkC,EAAEG,GAAG,CAAC;QACtDP,OAAO,CAACI,KAAK,CAAC,UAAU,EAAED,OAAO,CAAC;MACpC;IACF;IAEAH,OAAO,CAACC,GAAG,CAAC,uCAAuC,CAAC;IACpD,OAAO;MAAEO,OAAO,EAAE;IAAK,CAAC;EAC1B,CAAC,CAAC,OAAOJ,KAAK,EAAE;IACdJ,OAAO,CAACI,KAAK,CAAC,iCAAiC,EAAEA,KAAK,CAAC;IACvD,OAAO;MAAEI,OAAO,EAAE,KAAK;MAAEJ;IAAM,CAAC;EAClC;AACF,CAAC;AAED,eAAeL,cAAc","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}